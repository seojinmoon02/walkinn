<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Code Path â€“ Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.min.js"></script>
  <style>
    :root {
      --accent: #ef4136;
      --accent-soft: #fef4f3;
      --text-main: #111827;
      --text-sub: #6b7280;
      --border-soft: #e5e7eb;
    }

    body {
      gridMargin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
      color: var(--text-main);
    }

    /* ìº”ë²„ìŠ¤ ì˜ì—­ â€“ ë¹„ìœ¨/ì‚¬ì´ì¦ˆëŠ” ê·¸ëŒ€ë¡œ, ì™¸ê³½ì„ ë§Œ SVG ìŠ¤íƒ€ì¼ */
    main {
      gridMargin-top: 18px;
    }
    main canvas {
      background: #ffffff;
      box-shadow: 0 0 0 1px #ffffff, 0 2px 8px rgba(0, 0, 0, 0.08);
      border-radius: 4px;
    }

    #ui {
      width: 700px;
      max-width: 95vw;
      gridMargin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 14px;
    }

    #topRow {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
    }

    #levelTitle {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.02em;
      color: var(--accent);
    }

    #buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    button {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
      white-space: nowrap;
      transition: background 0.15s ease, color 0.15s ease, box-shadow 0.15s ease,
        transform 0.08s ease;
    }

    button.secondary {
      background: #ffffff;
      color: var(--accent);
      box-shadow: none;
    }

    button:hover {
      filter: none;
      background: #ff5c4e;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.18);
      transform: translateY(-1px);
    }

    button.secondary:hover {
      background: var(--accent-soft);
      color: var(--accent);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
    }

    #status {
      padding: 6px 10px;
      background: #ffffff;
      border-radius: 6px;
      border: 1px solid var(--border-soft);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
      color: var(--text-sub);
    }

    #instructions {
      padding: 8px 10px;
      background: var(--accent-soft);
      border-radius: 6px;
      border: 1px solid var(--accent);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
      line-height: 1.5;
      color: var(--text-main);
    }

    #instructions b {
      font-weight: 600;
      color: var(--accent);
    }
    @media (max-width: 640px) {
  body {
    align-items: stretch;   /* ê°€ìš´ë° ì •ë ¬ ëŒ€ì‹  ì „ì²´ í­ ì‚¬ìš© */
  }

  main {
    margin-top: 0;          /* ìœ„ìª½ ì—¬ë°± ì œê±° â†’ í™”ë©´ ìƒë‹¨ì— ë”± ë¶™ê²Œ */
    width: 100%;
    display: flex;
    justify-content: center;
  }

  main canvas {
    max-width: 100vw;       /* í˜¹ì‹œë¼ë„ ë„˜ì¹˜ì§€ ì•Šê²Œ */
  }

  #ui {
    width: 100%;
    max-width: 100%;
    padding: 0 12px 16px;   /* ë²„íŠ¼/í…ìŠ¤íŠ¸ëŠ” ì¢Œìš° ì•½ê°„ë§Œ ì—¬ë°± */
  }
}

  </style>

</head>
<body>
  <main></main>

  <div id="ui">
    <div id="topRow">
      <div>
        <div id="levelTitle">TRIP 0?</div>
      </div>
      <div id="buttons">
        <button id="backBtn" class="secondary">â† Back</button>
        <button id="resetBtn" class="secondary">Reset</button>
        <button id="undoBtn" class="secondary">Undo</button>  <!-- â˜… ì¶”ê°€ -->
        <button id="langBtn" class="secondary">EN</button>
        <button id="checkBtn">Check Answer</button>
      </div>
    </div>

    <div id="status">Start from the START point and draw your path.</div>

    <div id="instructions">
    <b>Mouse Controls</b><br>
    - Click an adjacent point to extend your path from START.<br>
    - You can only move up, down, left, right, or diagonally.<br>
    - Double-click to break the line; the next point becomes a jump (J).<br>
    - After finishing your route, press <b>Check Answer</b>.
    </div>
  </div>

  <script>
        const LANG = {
        en: {
                status: {
                start: "Begin your journey from the START marker. Chart your path across the grid.",
                reset: "Your route has been cleared. Youâ€™re ready to set off again.",
                split: "Path split â€” your next move will become a leap (J).",
                nearOnly: "You can only travel to nearby points. Try a step within reach.",
                noAnswer: "No official route is set for this TRIP yet.",
                correct: "Journey complete! ğŸ‰ Your path matches the official route.",
                wrong: "This route doesnâ€™t match the official path. Try exploring again.",
                undo: "Your last step has been undone."
                },
            instructions: `
        <b>Mouse Controls</b><br>
        â€¢ Click nearby points to draw your route across the grid.<br>
        â€¢ Move up, down, left, right, or diagonally.<br>
        â€¢ Double-click to break the route â€” the next move becomes a leap (J).<br>
        â€¢ Press <b>Check Route</b> when you're done exploring.
        `,
            trip: n => `TRIP ${n}`
        },

        kr: {
            status: {
            start: "START ì§€ì ì—ì„œ ë‹¹ì‹ ì˜ ì—¬ì •ì„ ì‹œì‘í•˜ì„¸ìš”. ê·¸ë¦¬ë“œë¥¼ ë”°ë¼ ê¸¸ì„ ê°œì²™í•´ë³´ì„¸ìš”.",
            reset: "ê²½ë¡œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì—¬ì •ì„ ì‹œì‘í•  ìˆ˜ ìˆì–´ìš”.",
            split: "ì„ ì´ ëŠê²¼ìŠµë‹ˆë‹¤. ë‹¤ìŒ ì ë¶€í„° ì í”„(J) êµ¬ê°„ìœ¼ë¡œ ì¸ì‹ë©ë‹ˆë‹¤.",
            nearOnly: "ì¸ì ‘í•œ ì (ìƒí•˜ì¢Œìš°/ëŒ€ê°ì„ )ìœ¼ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            noAnswer: "ì´ TRIPì€ ì•„ì§ ì •ë‹µ ê²½ë¡œê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
            correct: "ì—¬ì • ì™„ë£Œ! ğŸ‰ ë‹¹ì‹ ì˜ ê²½ë¡œê°€ ì •ë‹µê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤.",
            wrong: "ì´ ê²½ë¡œëŠ” ì •ë‹µê³¼ ì¼ì¹˜í•˜ì§€ ì•Šì•„ìš”. ë‹¤ì‹œ íƒí—˜í•´ë³´ì„¸ìš”.",
            undo: "ë§ˆì§€ë§‰ ì›€ì§ì„ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤."
            },
            instructions: `
        <b>ë§ˆìš°ìŠ¤ ì¡°ì‘</b><br>
        â€¢ ì¸ì ‘í•œ ì ë“¤ì„ í´ë¦­í•´ ê·¸ë¦¬ë“œ ìœ„ì— ì—¬ì •ì„ ê·¸ë¦½ë‹ˆë‹¤.<br>
        â€¢ ìƒí•˜ì¢Œìš° ë° ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆì–´ìš”.<br>
        â€¢ ë”ë¸”í´ë¦­í•˜ë©´ ê¸¸ì´ ëŠì–´ì§€ë©°, ë‹¤ìŒ ì´ë™ì€ ì í”„(J)ê°€ ë©ë‹ˆë‹¤.<br>
        â€¢ íƒí—˜ì„ ë§ˆì¹˜ë©´ <b>ì •ë‹µ í™•ì¸</b> ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.
        `,
            trip: n => `TRIP ${n}`
        }
        };


        let currentLang = "en";

    // ====== CONFIG ======

// ====== GLOBAL STATE ======
  // ====== ìº”ë²„ìŠ¤ / ê·¸ë¦¬ë“œ ê¸°ë³¸ ì„¤ì • ======
const GRID_SIZE        = 11;
const BASE_CANVAS_SIZE = 700;  // ë°ìŠ¤í¬íƒ‘ì—ì„œ ìµœëŒ€ í¬ê¸°
const BASE_MARGIN      = 60;
const CLICK_RADIUS     = 16;

let canvasSize = BASE_CANVAS_SIZE;
let gridMargin = BASE_MARGIN;
let spacing;


    // ë‹µì•ˆ: ë‚˜ì¤‘ì— ë„¤ê°€ ì±„ì›Œ ë„£ì„ ê³³
    // ì˜ˆì‹œ í˜•íƒœ: "1": ["F","RFD","F","LT","J","F"]
        const ANSWER_CODES = {
        1: [
            "J","J","L","F","L","F","RBD","F","LBD","RBD","F","RFD","F","F","F","RFD","F","RBD","LBD","F","RBD","F","L","F","R","F","R","F","L","F","L","F","R","F","LT","LT","J","J"
        ],
        2: [
            "J","J","F","RFD","F","LBD","F","LFD","RBD","RFD","LBD","LFD","RBD","LFD","F","R","R","R","F","LFD","RBD","LFD","LBD","RFD","RBD","LFD","F","LBD","F","RFD","L","F","F","LT","LT","J","LFD","R","R","R","LT","J","L","F","F","J","J"
        ],
        3: [
            "F","L","F","L","RT","RT","J","R","F","R","F","L","L","F","R","RT","RT","J","F","F","L","F","L","F","L","F","RT","RT","J","R","F","F","R","F","L","L","F","R","F","RT","RT","J","R","L","F","L"
        ],
        4: [
            "F","F","L","F","R","F","F","R","L","R","L","RFD","LFD","F","B","F","LFD","RFD","L","R","L","R","F","RT","RT","J","F","F","F","F","R","R","F","F","F","R","LT","LT","J","R","R","F","L","F"
        ],
        5: [
            "J","J","R","L","F","F","F","F","F","L","F","F","F","F","F","L","F","F","F","F","F","L","F","F","F","F","LT","LT","J","F","F","F","F","L","F","F","F","L","F","F","F","L","F","F","F","J","J","J"
        ],
        6: [
            "J","J","LFD","LFD","R","LFD","R","LFD","R","LFD","R","LFD","R","LFD","R","LFD","R","LFD","J","J"
        ],
        7: [
            "J","F","F","L","F","F","R","R","F","F","L","L","F","F","R","R","F","F","L","L","F","F","R","R","F","F","L","L","F","F","F","F","L","F","F","F","F","F","F","F","L","F","F","F","F","J","J"
        ],
        8: [
            "R","F","LFD","F","F","F","F","L","F","F","L","F","LFD","F","RFD","F","RFD","L","F","L","LT","LT","J","R","F","LFD","F","F","F","L","LBD","F","RT","RT","J","J","F","LFD","LBD","RT","RT","RT","J","J","J"
        ],
        9: [
            "J","J","F","F","F","F","F","F","R","F","F","F","RFD","F","RFD","F","RFD","F","RFD","F","F","F","RT","RT","RT","J","J","LFD","F","R","F","R","F","R","F","LT","LT","J","J","J","J"
        ],
        10: [
            "J","J","J","F","F","R","F","RBD","F","R","F","RBD","F","F","F","F","F","F","LBD","F","F","LFD","F","F","F","LFD","F","F","LBD","F","F","RT","RT","RT","J","J","J"
        ],
        11: [
            "LFD","F","LFD","RFD","F","R","F","L","R","F","F","RFD","R","F","F","F","F","F","F","F","F","F"
        ],
        12: [
            "J","F","F","F","F","F","F","F","F","RBD","F","F","F","LFD","F","LFD","F","RBD","F","F","F","RBD","F","LFD","F","LFD","F","F","F","RT","J"
        ],
        };


    // ê° ë ˆë²¨ë³„ START ìœ„ì¹˜ (ê²©ì index: i, j)
    // ê¸°ë³¸ê°’ìœ¼ë¡œ "ë§¨ ìœ„ ì¤‘ì•™"ìœ¼ë¡œ ë„£ì–´ë‘ . ë‚˜ì¤‘ì— ë³€ê²½ ê°€ëŠ¥.
    const START_POINTS = {
      1: { i: 8, j: 0 },
      2: { i: 0, j: 5 },
      3: { i: 0, j: 5 },
      4: { i: 0, j: 5 },
      5: { i: 0, j: 5 },
      6: { i: 0, j: 5 },
      7: { i: 0, j: 5 },
      8: { i: 0, j: 5 },
      9: { i: 0, j: 5 },
      10:{ i: 0, j: 5 },
      11:{ i: 0, j: 5 },
      12:{ i: 0, j: 5 },
    };

    // 0: N, 1: NE, 2: E, 3: SE, 4: S, 5: SW, 6: W, 7: NW
    const ORI_DIRS = [
      { di: -1, dj:  0 }, // N
      { di: -1, dj:  1 }, // NE
      { di:  0, dj:  1 }, // E
      { di:  1, dj:  1 }, // SE
      { di:  1, dj:  0 }, // S
      { di:  1, dj: -1 }, // SW
      { di:  0, dj: -1 }, // W
      { di: -1, dj: -1 }, // NW
    ];

    const DRAW_CODES = ["F", "L", "R", "B", "LFD", "RFD", "LBD", "RBD"];
    const ALL_CODES  = ["F","L","R","B","J","LFD","RFD","LBD","RBD","LT","RT"];

    // ====== GLOBAL STATE ======


// ====== GLOBAL STATE ======
let points = [];
let segments = [];
let activeSegment = null;
let currentPointIndex = null;
let startPoint = null;

let level = 1;

let statusDiv, backBtn, resetBtn, checkBtn, levelTitle, undoBtn, langBtn;
let resultMode = null; // "correct" | "wrong" | null
let resultTimer = 0;
let confetti = [];


    

    // ====== P5 SETUP / DRAW ======


// í™”ë©´ í¬ê¸°ì— ë§ì¶° ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
function updateCanvasSize() {
  // ê°€ë¡œëŠ” ë·°í¬íŠ¸ ì „ì²´ ì‚¬ìš©
  const sizeByWidth = windowWidth;        // â¬…ï¸ 0.9 â†’ 1.0

  // ì„¸ë¡œëŠ” ì•„ë˜ UI ì˜ì—­ì„ ìƒê°í•´ì„œ 60% ì •ë„ë§Œ ì‚¬ìš©
  const sizeByHeight = windowHeight * 0.6;

  // ë°ìŠ¤í¬í†±ì—ì„œëŠ” ìµœëŒ€ 700, ëª¨ë°”ì¼ì—ì„œëŠ” í™”ë©´ì— ë§ê²Œ ì¤„ì–´ë“¦
  canvasSize = Math.min(BASE_CANVAS_SIZE, sizeByWidth, sizeByHeight);

  resizeCanvas(canvasSize, canvasSize);

  // ìº”ë²„ìŠ¤ê°€ ì¤„ì–´ë“  ë§Œí¼ marginë„ ë¹„ìœ¨ë¡œ ë§ì¶”ê¸°
  gridMargin = canvasSize * 0.07;   // í•„ìš”í•˜ë©´ 0.06~0.08 ì‚¬ì´ë¡œ ì¡°ì ˆ
  spacing = (canvasSize - 2 * gridMargin) / (GRID_SIZE - 1);
}

// setup ì•ˆì—ì„œ í•œ ë²ˆ í˜¸ì¶œ
function setup() {
  const canvas = createCanvas(canvasSize, canvasSize);
  canvas.parent(document.querySelector("main"));

  updateCanvasSize();   // â¬…ï¸ ì¶”ê°€/ìœ ì§€

  textFont("system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif");
  initGrid();
  initLevelFromQuery();
  cacheDom();
  initGameState();
}

// ì°½ í¬ê¸° ë°”ë€” ë•Œë§ˆë‹¤ ë‹¤ì‹œ ë§ì¶”ê¸°
function windowResized() {
  updateCanvasSize();
}


function setup() {
  // ì¼ë‹¨ ì„ì‹œ í¬ê¸°ë¡œ ë§Œë“  ë’¤, updateCanvasSizeì—ì„œ ì‹¤ì œ í¬ê¸° ë§ì¶”ê¸°
  const canvas = createCanvas(BASE_CANVAS_SIZE, BASE_CANVAS_SIZE);
  canvas.parent(document.querySelector("main"));

  textFont("system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif");

  updateCanvasSize();        // í™”ë©´ í¬ê¸°ì— ë§ê²Œ ìº”ë²„ìŠ¤/ê·¸ë¦¬ë“œ ì¡°ì •
  initLevelFromQuery();
  cacheDom();
  initGameState();
}



    function draw() {
      background('#ef4136');
      drawGrid();
      drawSegments();
      drawPoints();
      drawStartMarker();
      drawResultOverlay();
      drawConfetti();
    }

    // ====== INIT / DOM ======
    function initLevelFromQuery() {
      const q = new URLSearchParams(window.location.search);
      const lv = parseInt(q.get("level"), 10);
      level = (!isNaN(lv) && lv >= 1 && lv <= 12) ? lv : 1;
    }

function cacheDom() {
  statusDiv   = document.getElementById("status");
  backBtn     = document.getElementById("backBtn");
  resetBtn    = document.getElementById("resetBtn");
  checkBtn    = document.getElementById("checkBtn");
  levelTitle  = document.getElementById("levelTitle");
  undoBtn     = document.getElementById("undoBtn");  // â˜… ì¶”ê°€

const L = LANG[currentLang];
levelTitle.textContent = L.trip(level);

  backBtn.addEventListener("click", () => {
    window.location.href = "landing.html";
  });

  resetBtn.addEventListener("click", () => {
    initGameState();
    setStatus("reset");
  });

  checkBtn.addEventListener("click", onCheckAnswer);

  // â˜… Undo ë²„íŠ¼ í´ë¦­
  undoBtn.addEventListener("click", () => {
    undoLastStep();
  });

  // â˜… Cmd+Z / Ctrl+Z ë‹¨ì¶•í‚¤
  window.addEventListener("keydown", (e) => {
    if ((e.key === "z" || e.key === "Z") && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      undoLastStep();
    }
  });

    langBtn = document.getElementById("langBtn");
    langBtn.addEventListener("click", () => {
        currentLang = currentLang === "en" ? "kr" : "en";
        langBtn.textContent = currentLang.toUpperCase();
        applyLanguage();
    });

}

function applyLanguage() {
  const L = LANG[currentLang];

  // TRIP ì œëª©
  levelTitle.textContent = L.trip(level);

  // ìƒíƒœ ë¬¸êµ¬ëŠ” ê³µìš© í•¨ìˆ˜ë¡œ ì²˜ë¦¬
  setStatus("start");

  // ì•ˆë‚´ ë¬¸êµ¬
  document.getElementById("instructions").innerHTML = L.instructions;
}



    function initGameState() {
      segments = [];
      activeSegment = null;
      currentPointIndex = null;
      resultMode = null;
      resultTimer = 0;
      confetti = [];

      // START ì„¤ì •
      const sp = START_POINTS[level] || { i: 0, j: Math.floor(GRID_SIZE/2) };
      const idx = ijToIndex(sp.i, sp.j);
      startPoint = points[idx];

      // ì²« segmentëŠ” STARTì—ì„œ ì‹œì‘
      activeSegment = { points: [idx] };
      segments.push(activeSegment);
      currentPointIndex = idx;

      setStatus("start");

      applyLanguage();


    }

function setStatus(keyOrMsg) {
  if (!statusDiv) return;
  const L = LANG[currentLang];

  // LANG.status ì•ˆì— ê°™ì€ í‚¤ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ì‚¬ìš©
  if (L && L.status && L.status[keyOrMsg]) {
    statusDiv.textContent = L.status[keyOrMsg];
  } else {
    // ì—†ìœ¼ë©´ ê·¸ëƒ¥ ì›ë˜ ë¬¸ìì—´ ê·¸ëŒ€ë¡œ (ë””ë²„ê·¸ìš©)
    statusDiv.textContent = keyOrMsg;
  }
}


    function indexToIJ(index) {
      const i = Math.floor(index / GRID_SIZE);
      const j = index % GRID_SIZE;
      return { i, j };
    }

    function ijToIndex(i, j) {
      return i * GRID_SIZE + j;
    }

    function isOnEdge(i, j) {
      return (
        i === 0 ||
        j === 0 ||
        i === GRID_SIZE - 1 ||
        j === GRID_SIZE - 1
      );
    }

    function initialOrientationForStart(i, j) {
      if (i === 0)             return 4; // top â†’ S
      if (i === GRID_SIZE - 1) return 0; // bottom â†’ N
      if (j === 0)             return 2; // left â†’ E
      if (j === GRID_SIZE - 1) return 6; // right â†’ W
      return 4;
    }

    // ====== COMMAND APPLY / ENCODE ======
    function applyCommand(ori, code) {
      let newOri = ori;
      let stepOri = ori;
      let type = "draw";

      switch (code) {
        case "F":
          stepOri = ori;
          break;
        case "B":
          newOri = (ori + 4) % 8;
          stepOri = newOri;
          break;
        case "L":
          newOri = (ori + 6) % 8;
          stepOri = newOri;
          break;
        case "R":
          newOri = (ori + 2) % 8;
          stepOri = newOri;
          break;
        case "J":
          stepOri = ori;
          type = "jump";
          break;
        case "LFD":
          newOri = (ori + 7) % 8;
          stepOri = newOri;
          break;
        case "RFD":
          newOri = (ori + 1) % 8;
          stepOri = newOri;
          break;
        case "LBD":
          newOri = (ori + 5) % 8;
          stepOri = newOri;
          break;
        case "RBD":
          newOri = (ori + 3) % 8;
          stepOri = newOri;
          break;
        case "LT":
          newOri = (ori + 7) % 8;
          stepOri = ori; // íšŒì „ë§Œ, ì´ë™ ì—†ìŒ
          return { newOri, di: 0, dj: 0, type: "rotate" };
        case "RT":
          newOri = (ori + 1) % 8;
          stepOri = ori;
          return { newOri, di: 0, dj: 0, type: "rotate" };
      }

      const d = ORI_DIRS[stepOri];
      return { newOri, di: d.di, dj: d.dj, type };
    }

    function buildStepsFromSegments() {
      if (!segments || segments.length === 0) return [];
      const chronological = [];

      for (let s = 0; s < segments.length; s++) {
        const seg = segments[s];
        if (!seg.points || seg.points.length === 0) continue;

        for (let k = 0; k < seg.points.length - 1; k++) {
          const from = seg.points[k];
          const to   = seg.points[k + 1];
          chronological.push({ from, to, type: "draw" });
        }

        if (s < segments.length - 1) {
          const nextSeg = segments[s + 1];
          if (seg.points.length > 0 && nextSeg.points.length > 0) {
            const from = seg.points[seg.points.length - 1];
            const to   = nextSeg.points[0];
            if (from !== to) {
              chronological.push({ from, to, type: "jump" });
            }
          }
        }
      }

      return chronological;
    }

    function encodeStep(ori, fromIndex, toIndex, type) {
      const from = indexToIJ(fromIndex);
      const to   = indexToIJ(toIndex);
      const di   = to.i - from.i;
      const dj   = to.j - from.j;

      // Jump: í˜„ì¬ ë°”ë¼ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ 1ì¹¸ì¼ ë•Œë§Œ Jë¡œ í‘œí˜„
      if (type === "jump") {
        const d = ORI_DIRS[ori];
        if (d.di === di && d.dj === dj) {
          return { code: "J", newOri: ori };
        } else {
          return null;
        }
      }

      // Draw: F/L/R/B/LFD/RFD/LBD/RBD ì¤‘ í•˜ë‚˜
      for (const c of DRAW_CODES) {
        const res = applyCommand(ori, c);
        if (res.type !== "draw") continue;
        if (res.di === di && res.dj === dj) {
          return { code: c, newOri: res.newOri };
        }
      }
      return null;
    }

    function encodeCurrentPath() {
      if (!startPoint) return { ok:false, error:"STARTê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", commands:[] };

      const steps = buildStepsFromSegments();
      if (steps.length === 0) {
        return { ok:false, error:"ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.", commands:[] };
      }

      const { i: si, j: sj } = indexToIJ(steps[0].from);
      if (!isOnEdge(si, sj)) {
        return { ok:false, error:"STARTëŠ” ê²©ì ë°”ê¹¥ ê°€ì¥ìë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤.", commands:[] };
      }

      let ori = initialOrientationForStart(si, sj);
      const cmds = [];

      for (let k = 0; k < steps.length; k++) {
        const st = steps[k];
        const encoded = encodeStep(ori, st.from, st.to, st.type);
        if (!encoded) {
          return {
            ok: false,
            error: `í•´ë‹¹ ì›€ì§ì„ì„ ì•”í˜¸ë¡œ í‘œí˜„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (step ${k+1})`,
            commands: []
          };
        }
        cmds.push(encoded.code);
        ori = encoded.newOri;
      }

      return { ok:true, error:"", commands:cmds };
    }

// ì •ë‹µ ì•”í˜¸ ë¦¬ìŠ¤íŠ¸(ANSWER_CODES[level])ë¥¼
// ì‹œì‘ ì¸ë±ìŠ¤/ë°©í–¥ ê¸°ì¤€ìœ¼ë¡œ "from/to/type" step ë°°ì—´ë¡œ ë””ì½”ë“œ
function decodeCommandsToSteps(commands, startIndex, startOri) {
  let steps = [];
  let ori = startOri;
  let currentIndex = startIndex;

  for (let k = 0; k < commands.length; k++) {
    const cmd = commands[k];
    const res = applyCommand(ori, cmd);

    if (!res) {
      return {
        ok: false,
        error: `ì •ë‹µ ì½”ë“œì˜ ${k + 1}ë²ˆì§¸ ëª…ë ¹(${cmd})ë¥¼ í•´ì„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
        steps: []
      };
    }

    // LT / RT ê°™ì€ íšŒì „ë§Œ ìˆëŠ” ê²½ìš°
    if (res.type === "rotate") {
      ori = res.newOri;
      continue;
    }

    const { i, j } = indexToIJ(currentIndex);
    const ni = i + res.di;
    const nj = j + res.dj;

    if (ni < 0 || ni >= GRID_SIZE || nj < 0 || nj >= GRID_SIZE) {
      return {
        ok: false,
        error: `ì •ë‹µ ì½”ë“œê°€ ê²©ì ë°–ìœ¼ë¡œ ë‚˜ê°‘ë‹ˆë‹¤. (step ${k + 1})`,
        steps: []
      };
    }

    const nextIndex = ijToIndex(ni, nj);
    steps.push({ from: currentIndex, to: nextIndex, type: res.type });
    currentIndex = nextIndex;
    ori = res.newOri;
  }

  return { ok: true, error: "", steps };
}

function compareSteps(ansSteps, playerSteps) {
  if (ansSteps.length !== playerSteps.length) return false;
  for (let i = 0; i < ansSteps.length; i++) {
    const a = ansSteps[i];
    const p = playerSteps[i];
    if (a.type !== p.type || a.from !== p.from || a.to !== p.to) {
      return false;
    }
  }
  return true;
}


    // ====== ANSWER CHECK ======
function onCheckAnswer() {
  const ans = ANSWER_CODES[level];
  if (!ans || !Array.isArray(ans) || ans.length === 0) {
    setStatus("noAnswer");
    return;
  }

  // 1) í”Œë ˆì´ì–´ê°€ ê·¸ë¦° ê²½ë¡œë¥¼ stepsë¡œ ê°€ì ¸ì˜¤ê¸°
  const playerSteps = buildStepsFromSegments();
  if (playerSteps.length === 0) {
    setStatus("ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ê·¸ë¦¼ì„ ê·¸ë ¤ì£¼ì„¸ìš”.");
    resultMode = null;
    resultTimer = 0;
    confetti = [];
    return;
  }

  // 2) ì •ë‹µ ì½”ë“œë¥¼ ê°™ì€ í˜•ì‹ì˜ stepsë¡œ ë””ì½”ë“œ
  const sp = START_POINTS[level] || { i: 0, j: Math.floor(GRID_SIZE / 2) };
  const startIndex = ijToIndex(sp.i, sp.j);
  const startOri = initialOrientationForStart(sp.i, sp.j);

  const decoded = decodeCommandsToSteps(ans, startIndex, startOri);
  if (!decoded.ok) {
    setStatus(decoded.error);
    resultMode = null;
    resultTimer = 0;
    confetti = [];
    return;
  }

  // 3) ë‘ step ë°°ì—´ì„ ë¹„êµ (ì¢Œí‘œ ê¸°ì¤€)
  const ok = compareSteps(decoded.steps, playerSteps);

    if (ok) {
    resultMode = "correct";
    resultTimer = 180;
    spawnConfetti();
    setStatus("correct");
    } else {
    resultMode = "wrong";
    resultTimer = 180;
    confetti = [];
    setStatus("wrong");
    }

}

    function compareCommands(ans, player) {
      if (ans.length !== player.length) return false;
      for (let i = 0; i < ans.length; i++) {
        if (ans[i] !== player[i]) return false;
      }
      return true;
    }

    // ====== MOUSE INTERACTION ======
    function mousePressed() {
      if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;

      const idx = findClickedPoint(mouseX, mouseY);
      if (idx === -1) return;

      handleClickOnPoint(idx);
    }

        function doubleClicked() {
    if (currentPointIndex != null) {
        activeSegment = null;
        currentPointIndex = null;
        setStatus("split");
    }
    return false;
    }
        


    function findClickedPoint(mx, my) {
      let closestIndex = -1;
      let closestDistSq = CLICK_RADIUS * CLICK_RADIUS;
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const dx = mx - p.x;
        const dy = my - p.y;
        const d2 = dx * dx + dy * dy;
        if (d2 <= closestDistSq) {
          closestIndex = i;
          closestDistSq = d2;
        }
      }
      return closestIndex;
    }
    function handleClickOnPoint(idx) {
    const p = points[idx];
    if (!startPoint) return;

    // 1) ì„¸ê·¸ë¨¼íŠ¸ê°€ ëŠì–´ì§„ ìƒíƒœ(currentPointIndex === null)ë¼ë©´
    //    â†’ ìƒˆ ì„¸ê·¸ë¨¼íŠ¸ì˜ "ì²« ì "ë§Œ ë§Œë“ ë‹¤ (ì´ê²Œ ì í”„ì˜ ë„ì°©ì ì´ ë¨)
    if (currentPointIndex == null) {
        activeSegment = { points: [idx] };  // â˜… ì´ì „ ì ì€ ë„£ì§€ ì•ŠìŒ
        segments.push(activeSegment);
        currentPointIndex = idx;
        return; // ì—¬ê¸°ì„œëŠ” ì¸ì ‘ ì²´í¬ë„ í•˜ì§€ ì•ŠìŒ
    }

    // 2) í‰ì†Œì²˜ëŸ¼ ê¸°ì¡´ ì„¸ê·¸ë¨¼íŠ¸ì— ì´ì–´ì„œ ê·¸ë¦´ ë•Œ
    const lastP = points[currentPointIndex];
    const di = p.i - lastP.i;
    const dj = p.j - lastP.j;

    if (
        Math.abs(di) > 1 ||
        Math.abs(dj) > 1 ||
        (di === 0 && dj === 0)
    ) {
        setStatus("nearOnly");
        return;
    }

    if (!activeSegment) {
        activeSegment = { points: [currentPointIndex] };
        segments.push(activeSegment);
    }

    activeSegment.points.push(idx);
    currentPointIndex = idx;
    }


    // ====== DRAW HELPERS ======
    function drawGrid() {
    push();

    // âœ… ê·¸ë¦¬ë“œ ë°°ê²½ (ì›í•˜ë©´ ì—¬ê¸° ìƒ‰ ë°”ê¾¸ë©´ ë¨! ì˜ˆ: ì•„ì£¼ ì—°í•œ ì•„ì´ë³´ë¦¬)
    noStroke();
    fill(255, 250, 245); // ì›í•˜ëŠ” ìƒ‰ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥
    rect(gridMargin, gridMargin, width - 2 * gridMargin, height - 2 * gridMargin);


    // âœ… ì ì„  ì„¤ì •
    stroke(255, 200, 195);      // ì—°í•œ ë¹¨ê°• ê³„ì—´
    strokeWeight(1);
    drawingContext.setLineDash([4, 4]); // [ì„  ê¸¸ì´, ê³µë°± ê¸¸ì´]

    // ê°€ë¡œì„ 
   for (let i = 0; i < GRID_SIZE; i++) {
  const y = gridMargin + i * spacing;
  line(gridMargin, y, width - gridMargin, y);
}

    // ì„¸ë¡œì„ 
 for (let j = 0; j < GRID_SIZE; j++) {
  const x = gridMargin + j * spacing;
  line(x, gridMargin, x, height - gridMargin);
}

    // âœ… ë‹¤ë¥¸ ê·¸ë¦¬ê¸°ì—ëŠ” ì ì„  ì•ˆ ë¨¹ë„ë¡ ë¦¬ì…‹
    drawingContext.setLineDash([]);

    pop();
    }


    function drawPoints() {
    push();
    noStroke();
    fill(239, 65, 54, 150);   // #EF4136 ê¸°ë°˜, ì•½ê°„ ë°˜íˆ¬ëª… (alpha 150)
    const r = 4;

    for (const p of points) {
        if (startPoint && p.index === startPoint.index) continue;
        circle(p.x, p.y, r * 2);
    }
    pop();
}


    function drawSegments() {
    if (!segments || segments.length === 0) return;

    push();                       // â† ë‹¤ë¥¸ ê·¸ë¦¬ê¸° ì„¤ì • ë³´í˜¸
    stroke(239, 65, 54);          // #EF4136 ë¹¨ê°„ìƒ‰
    strokeWeight(5);
    noFill();

    for (const seg of segments) {
        if (!seg.points || seg.points.length < 2) continue;
        for (let k = 0; k < seg.points.length - 1; k++) {
        const a = points[seg.points[k]];
        const b = points[seg.points[k + 1]];
        line(a.x, a.y, b.x, b.y);
        }
    }

    pop();
    }


    function drawStartMarker() {
    if (!startPoint) return;
    push();

    // ê¸°ë³¸ ì¢Œí‘œ (ê·¸ë¦¬ë“œ ìœ„ì˜ START ì )
    const sx = startPoint.x;
    const sy = startPoint.y;

    // STARTê°€ ì„œ ìˆëŠ” ë³€ ê¸°ì¤€ìœ¼ë¡œ ë°”ë¼ë³´ëŠ” ë°©í–¥ ê³„ì‚°
    const ori = initialOrientationForStart(startPoint.i, startPoint.j);
    const d   = ORI_DIRS[ori]; // {di, dj}

    // --- ìœ„ì¹˜ë¥¼ ê·¸ë¦¬ë“œ "ë°”ê¹¥" ìª½ìœ¼ë¡œ ì‚´ì§ ì´ë™ ---
    const shift = 22; // ìˆ«ì í‚¤ìš°ë©´ ë” ë°”ê¹¥ìœ¼ë¡œ ë‚˜ê°
    const cx = sx - d.dj * shift;
    const cy = sy - d.di * shift;

    // --- pulsing ìŠ¤ì¼€ì¼ ê³„ì‚° (ì‚´ì§ ìˆ¨ ì‰¬ë“¯ì´) ---
    const baseSize = 18; // ê¸°ë³¸ ì‚¼ê°í˜• í¬ê¸°
    const pulse    = 1 + 0.03 * Math.sin(millis() / 300); // 0.88 ~ 1.12 ì •ë„ ë°˜ë³µ
    const size     = baseSize * pulse;

    // ì‚¼ê°í˜• ê¼­ì§“ì  ê³„ì‚° (tip = ê²©ì ì•ˆìª½, left/right = ë°”ê¹¥ìª½)
    const tipX   = cx + d.dj * size;
    const tipY   = cy + d.di * size;
    const leftX  = cx + (-d.di) * size * 0.6;
    const leftY  = cy + ( d.dj) * size * 0.6;
    const rightX = cx + ( d.di) * size * 0.6;
    const rightY = cy + (-d.dj) * size * 0.6;

    // ìŠ¤íƒ€ì¼ (ê¸°ì¡´ ìƒ‰ ìœ ì§€)
    stroke(225);
    strokeWeight(1 * pulse);   // ì‚´ì§ ê°™ì´ ìˆ¨ ì‰¬ëŠ” ëŠë‚Œ
    fill(183, 245, 39);

    triangle(tipX, tipY, leftX, leftY, rightX, rightY);

    pop();
    }



    // ====== RESULT OVERLAY (O / X) + CONFETTI ======
    function drawResultOverlay() {
      if (!resultMode || resultTimer <= 0) return;
      resultTimer--;

      const cx = width / 2;
      const cy = height / 2;
      const gridW = width - 2 * gridMargin;
      const baseR = gridW * 0.45;

      if (resultMode === "correct") {
        noFill();
        stroke(46, 204, 113);
        strokeWeight(14);
        circle(cx, cy, baseR);
      } else if (resultMode === "wrong") {
        stroke(220, 38, 38);
        strokeWeight(14);
        const r = baseR * 0.7;
        line(cx - r, cy - r, cx + r, cy + r);
        line(cx - r, cy + r, cx + r, cy - r);
      }
    }

    function spawnConfetti() {
      confetti = [];
      const count = 200;
      for (let i = 0; i < count; i++) {
        confetti.push({
          x: random(0, width),
          y: random(-height, 0),
          vx: random(-0.5, 0.5),
          vy: random(2, 5),
          size: random(4, 8),
          col: color(random(200,255), random(150,230), random(80,200))
        });
      }
    }

    function undoLastStep() {
  if (!segments || segments.length === 0) return;

  // ë’¤ì—ì„œë¶€í„° "ì‹¤ì œ ì ì´ ìˆëŠ”" ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ ì°¾ê¸°
  let s = segments.length - 1;
  while (s >= 0 && (!segments[s].points || segments[s].points.length === 0)) {
    s--;
  }
  if (s < 0) return;

  let seg = segments[s];

  if (seg.points.length > 1) {
    // â˜… ë§ˆì§€ë§‰ ì  í•˜ë‚˜ë§Œ ì œê±°
    seg.points.pop();
    currentPointIndex = seg.points[seg.points.length - 1];
    activeSegment = seg;
  } else {
    // ì´ ì„¸ê·¸ë¨¼íŠ¸ì—” ì ì´ 1ê°œë¿ â†’ ì„¸ê·¸ë¨¼íŠ¸ ìì²´ë¥¼ ì œê±°
    segments.splice(s, 1);

    if (segments.length === 0) {
      // ì™„ì „íˆ ë¹„ì–´ ë²„ë¦¬ë©´ STARTë§Œ ìˆëŠ” ê¸°ë³¸ ìƒíƒœë¡œ ë³µì›
      if (startPoint) {
        const idx = startPoint.index;
        const baseSeg = { points: [idx] };
        segments = [baseSeg];
        activeSegment = baseSeg;
        currentPointIndex = idx;
      } else {
        activeSegment = null;
        currentPointIndex = null;
      }
    } else {
      // ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ì˜ ë§ˆì§€ë§‰ ì ì„ í˜„ì¬ ìœ„ì¹˜ë¡œ
      const lastSeg = segments[segments.length - 1];
      if (lastSeg.points && lastSeg.points.length > 0) {
        activeSegment = lastSeg;
        currentPointIndex = lastSeg.points[lastSeg.points.length - 1];
      } else {
        activeSegment = null;
        currentPointIndex = null;
      }
    }
  }

  // í˜¹ì‹œ ë‚¨ì•„ ìˆì„ ìˆ˜ ìˆëŠ” ë¹ˆ ì„¸ê·¸ë¨¼íŠ¸ ì •ë¦¬
  segments = segments.filter(seg => seg.points && seg.points.length > 0);

  // ê²°ê³¼ í‘œì‹œ(ë™ê·¸ë¼ë¯¸/X/ì»¨í˜í‹°) ì´ˆê¸°í™”
  resultMode = null;
  resultTimer = 0;
  confetti = [];

  setStatus("undo");
}


    function drawConfetti() {
      if (!resultMode || resultMode !== "correct" || confetti.length === 0) return;
      noStroke();
      for (const c of confetti) {
        fill(c.col);
        rect(c.x, c.y, c.size, c.size);
        c.x += c.vx;
        c.y += c.vy;
        if (c.y > height + 20) {
          c.y = random(-height, 0);
          c.x = random(0, width);
        }
      }
    }

    function initGrid() {
  points = [];
  let idx = 0;
  for (let i = 0; i < GRID_SIZE; i++) {
    for (let j = 0; j < GRID_SIZE; j++) {
      const x = gridMargin + j * spacing;
      const y = gridMargin + i * spacing;
      points.push({ x, y, i, j, index: idx++ });
    }
  }
}

  </script>
</body>
</html>
